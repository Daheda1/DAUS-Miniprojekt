import cv2 as cv
import numpy as np
import os
import numpy as np

def crown_detect(img_bgr, template_path, threshold, iou_thres):
    # The points of each found crown. The lenght of the list is the amount of crowns
    boxes = []
    assert img_bgr is not None, "file could not be read, check with os.path.exists()"
    for template in template_path:
        actual_temp = os.path.join(r"Templates", template)
        current_template = cv.imread(actual_temp)
        assert current_template is not None, "file could not be read, check with os.path.exists()"

        # Rotate the template
        for rotation in range(4):
            temp = np.rot90(current_template, rotation)
            h, w, _ = temp.shape
            res = cv.matchTemplate(img_bgr, temp, cv.TM_CCOEFF_NORMED)
            loc = np.where(res >= threshold)
            intersection_over_union(loc, h, w, boxes, img_bgr, iou_thres)
    return len(boxes)

def intersection_over_union(loc, h, w, boxes, img_bgr, iou_thres):
    for pts in zip(*loc[::-1]): 
        unions = []
        new_box = [pts[0], pts[1], pts[0] + w, pts[1] + h]

        if boxes == []:
            boxes.append(new_box)
            cv.rectangle(img_bgr, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
        else:
            for box in boxes:
                # Determine the x and y coordinates of the intersection for the template rectangles
                xA = max(box[0], new_box[0])
                yA = max(box[1], new_box[1])
                xB = min(box[2], new_box[2])
                yB = min(box[3], new_box[3])

                # Find the area where the template rectangles intersect
                interArea = (xB - xA) * (yB - yA)

                # Find the area for both templates
                boxAArea = (box[2] - box[0]) * (box[3] - box[1])
                boxBArea = (new_box[2] - new_box[0]) * (new_box[3] - new_box[1])

                # Find the intersection over union and test that we don't divide by 0
                if interArea == 0 or float(boxAArea + boxBArea - interArea) == 0:
                    iou = 0
                else:
                    iou = interArea / float(boxAArea + boxBArea - interArea)
                unions.append(iou)

            # Checks if the new box doesn't overlap with any of the other rectangles
            if all(i < iou_thres for i in unions):
                boxes.append(new_box)
                cv.rectangle(img_bgr, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
    return boxes

def another():
    img_bgr = cv.imread(r'Data\KD Train plader\57.jpg') #Data\KD Train plader\15.jpg Data\KD Train plader\57.jpg Data\KD Train plader\6.jpg 4
    template_path = os.listdir(r"Templates")
    threshold = 0.75
    iou_thres = 0.2

    boxes = crown_detect(img_bgr, template_path, threshold, iou_thres)
    print(boxes)
    cv.imwrite('res.jpg', img_bgr)
    cv.imshow('res.jpg', img_bgr)
    cv.waitKey(0)

another()
