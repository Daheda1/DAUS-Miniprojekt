import cv2 as cv
import numpy as np
import os
import numpy as np

def crown_detect(img_bgr, template_path, threshold, iou_thres):
    boxes = []
    assert img_bgr is not None, "file could not be read, check with os.path.exists()"
 
    for template in template_path:
        #   print(template)
        actual_temp = os.path.join(r"Templates", template)
        current_template = cv.imread(actual_temp)
        assert current_template is not None, "file could not be read, check with os.path.exists()"

        for rotation in range(4):
            temp = np.rot90(current_template, rotation)
            h, w, _ = temp.shape
            res = cv.matchTemplate(img_bgr, temp, cv.TM_CCOEFF_NORMED)
            loc = np.where(res >= threshold)

            intersection_over_union(loc, h, 3, boxes, img_bgr, iou_thres)
    return len(boxes)

def intersection_over_union(loc, h, w, boxes, img_bgr, iou_thres):
    for pts in zip(*loc[::-1]): 
        unions = []
        new_box = [pts[0], pts[1], pts[0] + w, pts[1] + h]

        if boxes == []:
            boxes.append(new_box)
            cv.rectangle(img_bgr, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
        else:
            for box in boxes:
                # determine the (x, y)-coordinates of the intersection rectangle
                xA = max(box[0], new_box[0])
                yA = max(box[1], new_box[1])
                xB = min(box[2], new_box[2])
                yB = min(box[3], new_box[3])

                # compute the area of intersection rectangle
                interArea = (xB - xA) * (yB - yA)

                # compute the area of both the prediction and ground-truth
                # rectangles
                boxAArea = (box[2] - box[0]) * (box[3] - box[1])
                boxBArea = (new_box[2] - new_box[0]) * (new_box[3] - new_box[1])

                # compute the intersection over union by taking the intersection
                # area and dividing it by the sum of prediction + ground-truth
                # areas - the interesection area
                if interArea == 0 or float(boxAArea + boxBArea - interArea) == 0:
                    iou = 0
                else:
                    iou = interArea / float(boxAArea + boxBArea - interArea)
                unions.append(iou)

            if all(i < iou_thres for i in unions):
                boxes.append(new_box)
                cv.rectangle(img_bgr, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
    return boxes

def another():
    img_bgr = cv.imread(r'Data\KD Train plader\4.jpg') #Data\KD Train plader\15.jpg Data\KD Train plader\57.jpg Data\KD Train plader\6.jpg 4
    template_path = os.listdir(r"Templates")
    threshold = 0.75
    iou_thres = 0.2

    boxes = crown_detect(img_bgr, template_path, threshold, iou_thres)
    print(boxes)
    cv.imwrite('res.jpg', img_bgr)
    cv.imshow('res.jpg', img_bgr)
    cv.waitKey(0)

another()
