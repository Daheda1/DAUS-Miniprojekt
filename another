import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt
import os

match_count = 0
boxes = []


img_rgb = cv.imread(r'Data\KD Train plader\6.jpg') #Data\KD Train plader\15.jpg Data\KD Train plader\57.jpg Data\KD Train plader\6.jpg
assert img_rgb is not None, "file could not be read, check with os.path.exists()"
img_gray = cv.cvtColor(img_rgb, cv.COLOR_BGR2GRAY)

for path, folders, templates in os.walk(r"D:\DAKI\semester_2\king_domino\github\DAUS-Miniprojekt\Templates"):

    for template in templates:
        actual_file = r"Templates" + "\\" + template
        current_template = cv.imread(actual_file, cv.IMREAD_GRAYSCALE)
        assert current_template is not None, "file could not be read, check with os.path.exists()"
        w, h = current_template.shape[::-1]

        res = cv.matchTemplate(img_gray, current_template, cv.TM_CCOEFF_NORMED)
        threshold = 0.7
        loc = np.where(res >= threshold)

        for pts in zip(*loc[::-1]):
            
            unions = []

            #Get the full box
            new_box = [pts[0], pts[1], pts[0] + w, pts[1] + h]

            if boxes == []:
                boxes.append(new_box)
                cv.rectangle(img_rgb, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
                match_count += 1
            else:
                for box in boxes:
                    # determine the (x, y)-coordinates of the intersection rectangle
                    xA = max(box[0], new_box[0])
                    yA = max(box[1], new_box[1])
                    xB = min(box[2], new_box[2])
                    yB = min(box[3], new_box[3])

                    # compute the area of intersection rectangle
                    interArea = (xB - xA) * (yB - yA)

                    # compute the area of both the prediction and ground-truth
                    # rectangles
                    boxAArea = (box[2] - box[0]) * (box[3] - box[1])
                    boxBArea = (new_box[2] - new_box[0]) * (new_box[3] - new_box[1])

                    # compute the intersection over union by taking the intersection
                    # area and dividing it by the sum of prediction + ground-truth
                    # areas - the interesection area
                    iou = interArea / float(boxAArea + boxBArea - interArea)
                    unions.append(iou)

                if all(i < 0.2 for i in unions):
                    boxes.append(new_box)
                    cv.rectangle(img_rgb, pts, (pts[0] + w, pts[1] + h), (0,0,255), 2)
                    match_count += 1
        break

print(match_count)
cv.imwrite('res.jpg',img_rgb)